{% extends 'base.html' %}
{% block title %}
    {{ prData.Title }}
{% endblock %}


{% block head %}


<!-- Include Quill.js stylesheet -->
<!-- <link href="https://cdn.quilljs.com/1.3.6/quill.snow.css" rel="stylesheet"> -->
<link rel="stylesheet" href="{{ url_for('static', filename='quill.snow.css') }}">
<link rel="stylesheet" href="{{ url_for('static', filename='dropzon.css') }}">

<!-- <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/dropzone/5.9.3/dropzone.min.css"> -->
<!-- <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/cropperjs/1.5.12/cropper.min.css"> -->
<link rel="stylesheet" href="{{ url_for('static', filename='dropzone.min.css') }}">
<link rel="stylesheet" href="{{ url_for('static', filename='cropper.min.css') }}"> 

<!-- Pickr themes (Color picker for reach text editor) -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@simonwep/pickr/dist/themes/classic.min.css"/>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@simonwep/pickr/dist/themes/monolith.min.css"/>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@simonwep/pickr/dist/themes/nano.min.css"/>

<style>
    .dz-details:hover {
        cursor: all-scroll;
    }

    .dz-remove-btn:hover {
        background-color: #c82333;
        cursor: pointer;
    }


    .alt-input:hover {
        cursor: auto;
    }

    .ql-editor .ql-align-center {
        text-align: center;
    }

</style>

<script type="text/javascript">
document.addEventListener('DOMContentLoaded', function(){
    
    let closedNav = true;
    const openWith = "11%";
    const closeWith = "0";
    
    document.getElementById('toggle-btn').onclick = function() {
        let sidebar = document.getElementById("topLeftNav");
        sidebar.classList.toggle('collapsed');
    
    };


    let popoverTriggers = document.querySelectorAll('.popoverImage');
    
    popoverTriggers.forEach(function(popoverTrigger) {
        let timeoutId;
        let hideTimeoutId;  // Variable to hold the hide timeout
    
        popoverTrigger.addEventListener('mouseenter', function() {
        clearTimeout(hideTimeoutId); // Clear any existing hide timeout
        timeoutId = setTimeout(function() {
            let popover = new bootstrap.Popover(popoverTrigger, {
            container: 'body',
            html: true,
            placement: 'top',
            trigger: 'manual',
            content: function() {
                return popoverTrigger.getAttribute("data-bs-content");
            }
            });
            popover.show();
        }, 2000); // Delay time in milliseconds for showing the popover
        });
    
        popoverTrigger.addEventListener('mouseleave', function() {
        clearTimeout(timeoutId); // Clear the show timeout if the mouse leaves before the popover is shown
        var popoverInstance = bootstrap.Popover.getInstance(popoverTrigger);
        if (popoverInstance) {
            hideTimeoutId = setTimeout(function() {  // Delay the hide action
            popoverInstance.hide();
            }, 2000);  // 2000 milliseconds delay before hiding the popover
        }
        });
    });
    

});    

</script>

{% endblock %}


{% block content %}

<header class="stuff-header">
    <div style="display: flex; align-items: center;">
        <button class="toggle-btn" id="toggle-btn" >
            <i class="fa-solid fa-screwdriver-wrench" style="font-size: 30px;"></i>
          </button>
    </div>
    <div style="position: relative; display: inline-block;">
        <nav>
            <a href="{{ url_for('home', _external=True) }}stuff" style="margin: 0 15px; color: #4a4a4a; text-decoration: none;">{{ _('Dashboard') }}</a>
            <a href="{{ url_for('home') }}about" style="margin: 0 15px; color: #007bff; text-decoration: none;">About</a>
            <a href="{{ url_for('home') }}contact" style="margin: 0 15px; color: #007bff; text-decoration: none;">Contact</a>
            
        </nav>
    </div>
</header>


<!-- Top Left Navigation Bar -->
<nav class="top-left-nav collapsed" id="topLeftNav">
    <a class="top-left-nav-a" 
        href="{{ url_for('home', _external=True) }}stuff" 
        style="text-decoration: none;"
        >
        {{ _('Dashboard') }}
        
    </a>
    <button class="chooseBlock" id="sliderButton">{{ _('Slider') }}</button>
    <button class="chooseBlock" id="headerButton">{{ _('Header') }}</button>
    <button class="chooseBlock" id="textEditorButton">{{ _('Editor') }}</button>
    <button class="chooseBlock" id="thumbnailButton">{{ _('Thumbnail') }}</button>
    <a class="top-left-nav-a" 
    href="{{ url_for('add_price', prID=prData['Product_ID'], _external=True) }}"  
        target="_blank"
        style="text-decoration: none;"
        >
        
            <!-- {{ _('Add Product Type') }} -->
            {{ _('Add Price') }}
    </a>


    {% if prData.Status == 2 %}
        <a class="top-left-nav-a" 
            href="{{ url_for('home', _external=True) + prData['Url'] }}" 
            target="_blank"
            style="text-decoration: none;"
            >
            
                {{ _('View') }}
        </a>
    {% endif %}

      <select class="styled-select changePrOrder" style="margin-bottom: 10px;">
        {% for row in ordering.data %}
          <option value="{{ row['Order'] }}" {{ 'selected' if row['Order'] ==  prData.Order  else '' }}>{{ row['Order'] }}</option>
        {% endfor %}
      </select>
    

    {% if supportedLangsData | length > 1 %}     
      <select onchange="location = '/setlang?lang=' + this.value;" class="styled-select">
        {% for lang in supportedLangsData %}
          <option value="{{ lang['Prefix'] }}" {{ 'selected' if get_locale() ==  lang['Prefix']  else '' }}>{{ lang['Language'] }}</option>
        {% endfor %}
      </select>
    {% endif %}
    
    {% set checked='' %}
    {% if prData.Status == 2 %}
        {% set checked='checked' %}
    {% endif %}

    <div class="publish">
        <label class="switch" id="mySwitch">
            <span class="sliderA round {{ checked }}"></span>
        </label>
    </div>
</nav>

<!-- Top Right Navigation Bar -->

<!-- Middle part -->
<input type="hidden" value="{{ prData.RefKey }}" id="RefKey">
<input type="hidden" id="language-id" value="{{ languageID }}">

<div class="overlay" id="overlay"></div>

<!-- Client -->
<div class="containerZ"> 
    
    <div id="mistakes" style="width: 100%; color: red; display: none; margin-bottom: 5px;"></div>
    <!-- Slide Show and image uploader -->
    <span class="blocks hidden" id="mySlideShow">


        <form action="/upload" class="dropzone" id="myDropzone">
            <div class="dz-message dz-button">{{ _('Click here to upload files') }}</div>
        </form>

        <!-- <button id="uploadButton">{{ _('Submit') }}</button> -->
        <div id="uploadButton" class="" >{{ _('Submit') }}</div>
        <div id="saveUploads" class="pcButtonS hidden" >{{ _('Saving...') }}</div>
        <div id="cencelUpload" class="pcButtonS" >{{ _('Cencel') }}</div>
        <!-- <button id="saving-btn" class=" ">Saving...</button> -->

    

 

    <!-- Script for Dropzone (image upload) -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/dropzone/5.9.3/dropzone.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/cropperjs/1.5.12/cropper.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/Sortable/1.15.0/Sortable.min.js"></script>
    <script>
        document.getElementById('cencelUpload').addEventListener('click', function(){
            document.getElementById('mySlideShow').style.display = 'none';
            document.getElementById('mySlideShow').classList = 'blocks hidden';
            if (document.getElementById('slides') !== 'undefined') {
                document.getElementById('slides').style.display = 'flex';
                document.getElementById('editorContent').style.display = 'block';
            }
        });
    </script>
    <script>
let csrfToken = "{{ csrf_token() }}";
let cropperState = 0;
let imgAlt = '', slider_id = '', imageURL = '';
let targetedInput;

const prData = {{ prData | tojson }};
const prSaving = prData.prSaving;
const prUpdate = prData.prUpdate;

// Initialize Dropzone
Dropzone.autoDiscover = false;
let myDropzone = new Dropzone("#myDropzone", {
    url: "/upload",
    autoProcessQueue: false,
    addRemoveLinks: false,
    previewsContainer: "#myDropzone",
    clickable: true,
    init: function () {
        let dz = this;
        


        

dz.on("addedfile", function (file) {
    let reader = new FileReader();
    reader.onload = function (event) {
        let imageUrl = event.target.result;

        openImageEditorModal(imageUrl, true, function (editedImageBlob) {
            // Find the index of the newly added file in myDropzone.files
            let fileIndex = myDropzone.files.indexOf(file);

            if (fileIndex === -1) return; // File not found in Dropzone

            // Create a completely new File object with the edited image data
            let editedFile = new File([editedImageBlob], file.name, { type: file.type });

            // Replace the file in Dropzone's file list
            myDropzone.files[fileIndex] = editedFile;

            // Preserve Dropzone's references and update the preview
            editedFile.previewElement = file.previewElement;

            // Update the preview with the cropped image
            let updatePreviewReader = new FileReader();
            updatePreviewReader.onload = function (e) {
                editedFile.previewElement.querySelector('img').src = e.target.result;
                editedFile.previewElement.querySelector('img').style.width = '100%';
                editedFile.previewElement.querySelector('.dz-image').style.width = '120px';
                editedFile.previewElement.querySelector('.dz-image').style.height = '120px';
            };
            updatePreviewReader.readAsDataURL(editedImageBlob);
        });
    };
    reader.readAsDataURL(file);

    // Custom elements for alt text and upload status
    let removeButton = Dropzone.createElement("<button class='dz-remove-btn'>&times;</button>");
    removeButton.addEventListener("click", function (e) {
        e.preventDefault();
        e.stopPropagation();
        dz.removeFile(file);
    });
    file.previewElement.appendChild(removeButton);

    let altInput = Dropzone.createElement("<input type='text' class='alt-input' placeholder='Enter alt text'>");
    altInput.value = imgAlt || '';
    file.previewElement.appendChild(altInput);
    
    let slideID = Dropzone.createElement("<input type='hidden' class='slideID' value='1'>");
    slideID.value = slider_id || '';
    file.previewElement.appendChild(slideID);
    
    let uploadItem = Dropzone.createElement("<input type='hidden' class='uploadStatus' value='1'>");
    file.previewElement.appendChild(uploadItem);

    // Hide progress bars
    file.previewElement.querySelectorAll("[data-dz-uploadprogress], .dz-progress").forEach(function (progressBar) {
        progressBar.style.display = "none";
    });

    targetedInput = file.previewElement;
});

// Edit existing files on double-click
dz.on("addedfile", function (file) {
    let previewElement = file.previewElement;

    previewElement.addEventListener('dblclick', function (event) {
        cropperState = 1;

        let previewElement = event.target.closest('.dz-preview');
        targetedInput = previewElement;

        if (previewElement) {
            let fileName = previewElement.querySelector('[data-dz-name]').textContent;
            let fileIndex = myDropzone.files.findIndex(f => f.name === fileName);
            let existingFile = myDropzone.files[fileIndex];

            if (existingFile) {
                let reader = new FileReader();
                reader.onload = function (event) {
                    let imageUrl = event.target.result;

                    openImageEditorModal(imageUrl, false, function (editedImageBlob) {
                        // Create a completely new file object
                        let editedFile = new File([editedImageBlob], existingFile.name, { type: existingFile.type });

                        // Replace the file in myDropzone.files to ensure it’s the new cropped version
                        myDropzone.files[fileIndex] = editedFile;

                        // Manually set the preview element to the new file, preserving Dropzone's reference
                        editedFile.previewElement = previewElement;

                        // Update the preview with the cropped image
                        let updatePreviewReader = new FileReader();
                        updatePreviewReader.onload = function (e) {
                            previewElement.querySelector('img').src = e.target.result;
                            previewElement.querySelector('img').style.width = '100%';
                            previewElement.querySelector('.dz-image').style.width = '120px';
                            previewElement.querySelector('.dz-image').style.height = '120px';
                        };
                        updatePreviewReader.readAsDataURL(editedImageBlob);
                    });
                };
                reader.readAsDataURL(existingFile);
            }
        }
    });
});


    }
});


let sortable = new Sortable(document.querySelector("#myDropzone"), {
    onEnd: function (evt) {
        let reorderedFiles = [];
        
        document.querySelectorAll("#myDropzone .dz-preview").forEach(function (element) {
            // Find file in Dropzone based on previewElement
            let file = myDropzone.files.find(function (file) {
                return file && file.previewElement === element;
            });

            if (file) { // Only push if the file is valid
                reorderedFiles.push(file);
            }
        });

        // Update Dropzone's files array with the new order
        myDropzone.files = reorderedFiles;
        // console.log(myDropzone.files); // Now the files array matches the preview order
    }
});
            
            // Initialize Sortable.js
            Sortable.create(myDropzone.previewsContainer, {
                draggable: ".dz-preview",
                onEnd: function (evt) {
                    // Handle reorder logic if necessary
                    console.log("Files reordered:", evt);
                }
            });


// Image Editor Modal Logic
let cropper;

function openImageEditorModal(imageUrl, closeBtn, callback) {
    let btn = `<button id="cancelEdit">{{ _('Close') }}</button>`
    if (cropperState === 1) {
        if (closeBtn === true) {
            btn = ''
        }
        document.getElementById('overlay').classList.add('show');
        let imageEditorModal = document.createElement('div');
        imageEditorModal.id = 'imageEditorModal';
        imageEditorModal.className = 'modal open';
        imageEditorModal.innerHTML = `
            <img id="imageToEdit" src="${imageUrl}" alt="Image to edit">
            <br>
            <button id="saveEditedImage">{{ _('Crop') }}</button>
            ${btn}
        `;
        document.body.appendChild(imageEditorModal);

        let imageToEdit = document.getElementById('imageToEdit');
        cropper = new Cropper(imageToEdit, {
            aspectRatio: 2 / 1.5,
            viewMode: 1,
            ready: function () {
                let cropperInstance = this.cropper;
                let naturalWidth = cropperInstance.imageData.naturalWidth;
                let naturalHeight = cropperInstance.imageData.naturalHeight;
                cropperInstance.setCropBoxData({
                    width: naturalWidth,
                    height: naturalHeight / (2 / 1.5),
                    left: (naturalWidth - naturalWidth) / 2,
                    top: (naturalHeight - naturalHeight / (2 / 1.5)) / 2
                });
            }
        });

        document.getElementById('saveEditedImage').onclick = function () {
            cropper.getCroppedCanvas().toBlob(function (blob) {
                closeImageEditorModal(imageEditorModal);
                callback(blob);
            });
            
                // Find a child element with the 'uploadStatus' class
            let childWithUploadStatus = targetedInput.querySelector('.uploadStatus');

            if (childWithUploadStatus) {
                targetedInput.querySelector('.uploadStatus').value = 0;
                stVal = targetedInput.querySelector('.uploadStatus').value;
                console.log(`A child element has the "uploadStatus" class with val ${stVal}`);
            } else {
                console.log('No child element has the "uploadStatus" class');
            }

            targetedInput = '';

        };        
        
        document.getElementById('cancelEdit').onclick = function () {
            closeImageEditorModal(imageEditorModal);
        };
    }
}


function closeImageEditorModal(modal) {
    cropper.destroy();
    modal.remove();
    document.getElementById('overlay').classList.remove('show');
}

    </script>

        <!-- End of script for Dropzone (image upload) -->
       
        <script>
            function productCategoryDropDown() {

                const productCategory = {{ productCategory | tojson }}

            const dropdownContainer = document.getElementById('pcDropDown');
            if (productCategory.product_category.length > 0) {
                const select = document.createElement('select');
                select.name = 'product-category';
                select.id = 'category-id';
                select.classList.add('form-control');

                const defaultOption = document.createElement('option');
                defaultOption.value = '';
                defaultOption.textContent = '{{ _("Choose product category") }}';
                select.appendChild(defaultOption);

                productCategory.product_category.data.forEach(val => {
                    const optVal = val['Product_Category_Name'];
                    if (optVal !== null) {
                        const option = document.createElement('option');
                        option.value = val['Product_Category_ID'];
                        if (prData.Product_Category_ID === val['Product_Category_ID']) {
                            option.selected = true;
                        }
                        option.textContent = optVal;
                        select.appendChild(option);
                    }
                });

                dropdownContainer.appendChild(select); // Append the select element to the body or any other specific location
            }
        };


            function openHeaderEditorModal(prData) {
                // Show the overlay
                document.getElementById('overlay').classList.add('show');

                // Create modal element
                let ProductName = prData.Title;
                ProductLink = prData.Url;
                ProductLink = prData.Url;
                languageID = prData.LanguageID;
                ShortDescription = prData.ShortDescription;
                LongDescription = prData.LongDescription;

                headerEditorModal = document.createElement('div');
                headerEditorModal.id = 'headerEditorModal';
                headerEditorModal.className = 'modal open';
                headerEditorModal.innerHTML = `
    <div type="button" class="close" id="cancelHeaderEdit" aria-label="Close">
        <span aria-hidden="true">&times;</span>
    </div>
    <div class="modal-header">
        <h5 class="modal-title">{{ _('Edit Header') }}</h5>
    </div>
    <div class="modal-body">
        <div class="form-group row">
            <p id="mistakes_modal"></>
        </div>    
        <form id="add-product-form" class="form">
            <div class="form-group row">
                <label for="product-name" class="col-sm-3 col-form-label">{{ _('Product name') }}</label>
                <div class="col-sm-9">
                    <input type="text" class="form-control" value="${ProductName}" id="product-name" >
                </div>
            </div>
            <div class="form-group row">
                <label for="product-link" class="col-sm-3 col-form-label">{{ _('Product link') }}</label>
                <div class="col-sm-9">
                    <input type="text" class="form-control" value="${ProductLink}" id="product-link" >
                </div>
            </div>
                    
            <div class="form-group row">
                <label for="short-description" class="col-sm-3 col-form-label">{{ _('Short Description') }}</label>
                <div class="col-sm-9">
                    <input type="text" id="short-description" class="form-control" value="${ShortDescription}" }}" />
                </div>
            </div>
            
            <div class="form-group row">
                <label for="long-description" class="col-sm-3 col-form-label">{{ _('Long Description') }}</label>
                <div class="col-sm-9">
                    <textarea id="long-description" class="form-control" placeholder="{{ _('Long description') }}" style="padding: 21px; font-family: Arial, sans-serif;">${LongDescription}</textarea>
                </div>
            </div>


            <div class="form-group row" id="pcDropDown"></div>
                    
            <div class="form-group row">
                <div class="col-sm-12 text-right">
                    <div class="middleButtun" id="saveEditedHeader">${prUpdate}</div>
                    <div id="saving" class="hidden middleButtun">${prSaving}</div>
                </div>
            </div>
        </form>
    </div>
`;
                document.body.appendChild(headerEditorModal);
                productCategoryDropDown();

                const inputElement = document.getElementById("product-link");

                inputElement.addEventListener("keyup", (event) => {
                const newValue = event.target.value.replace(/\s/g, "-");
                inputElement.value = newValue;
                });

                // When the form is submitted
                const saveButton = document.getElementById('saveEditedHeader');
                
                saveButton.addEventListener("click", function (event) {
                    // Prevent the default form submission
                    event.preventDefault();

    const saveButton = document.getElementById('saveEditedHeader');
    const saving = document.getElementById('saving');

    saveButton.classList.add('hidden');
    saving.classList.remove('hidden');

    // Get the category name from the input field
    let productName = document.getElementById('product-name').value;
    let productLink = document.getElementById('product-link').value;
    let languageID = document.getElementById('language-id').value;
    let CategoryID = document.getElementById('category-id').value;
    let RefKey = document.getElementById('RefKey').value;
    let shortDescription = document.getElementById('short-description').value;
    let longDescription = document.getElementById('long-description').value;


    // Create a new FormData object
    let formData = new FormData();
    formData.append('productName', productName);
    formData.append('productLink', productLink);
    formData.append('CategoryID', CategoryID);
    formData.append('languageID', languageID);
    formData.append('short-description', shortDescription);
    formData.append('long-description', longDescription);
    formData.append('RefKey', RefKey);
  

    
    
    // Create a new XMLHttpRequest object
    let xhr = new XMLHttpRequest();
    
    
    // Configure the request
    xhr.open('POST', '/edit_product_headers');
    

    xhr.setRequestHeader('X-CSRFToken', csrfToken);

    // Define what happens on successful data submission
    xhr.onload = function () {
        if (xhr.status === 200) {
            let response = JSON.parse(xhr.responseText);

            let mistakesDiv = document.getElementById('mistakes_modal');
            mistakesDiv.innerHTML = ''; // Clear previous messages

            if (response.status === '2') {
                // Handle empty product name
                mistakesDiv.innerHTML = response.answer;
                mistakesDiv.style.color = 'red';

                // Scroll the window to the mistakesDiv with smooth behavior
                mistakesDiv.scrollIntoView({ behavior: 'smooth' });

                saveButton.classList.remove('hidden');
                saving.classList.add('hidden');

            } else if (response.status === '3') {
                // Handle existing product name
                mistakesDiv.textContent = response.answer;
                mistakesDiv.style.color = 'red';

                // Scroll the window to the mistakesDiv with smooth behavior
                mistakesDiv.scrollIntoView({ behavior: 'smooth' });

                saveButton.classList.remove('hidden');
                saving.classList.add('hidden');

            } else if (response.status === '4') {
                // Handle empty product link
                mistakesDiv.textContent = response.answer;
                mistakesDiv.style.color = 'red';

                // Scroll the window to the mistakesDiv with smooth behavior
                mistakesDiv.scrollIntoView({ behavior: 'smooth' });

                saveButton.classList.remove('hidden');
                saving.classList.add('hidden');

            } else if (response.status === '5') {
                // Handle existing product link
                mistakesDiv.textContent = response.answer;
                mistakesDiv.style.color = 'red';

                // Scroll the window to the mistakesDiv with smooth behavior
                mistakesDiv.scrollIntoView({ behavior: 'smooth' });

                saveButton.classList.remove('hidden');
                saving.classList.add('hidden');

            }  else if (response.status === '6') {
                // Handle product category error
                mistakesDiv.textContent = response.answer;
                mistakesDiv.style.color = 'red';
                
                // Scroll the window to the mistakesDiv with smooth behavior
                mistakesDiv.scrollIntoView({ behavior: 'smooth' });
                
                saveButton.classList.remove('hidden');
                saving.classList.add('hidden');
                
            }  else if (response.status === '0') {
                // Handle Unknown Error
                mistakesDiv.textContent = response.answer;
                mistakesDiv.style.color = 'red';

                // Scroll the window to the mistakesDiv with smooth behavior
                mistakesDiv.scrollIntoView({ behavior: 'smooth' });

                saveButton.classList.remove('hidden');
                saving.classList.add('hidden');

            } else if (response.status === '1') {
                // Handle success
                // alert(response.answer);
                let currentUrl = window.location.href;
                location.href = currentUrl;
            }
        } else {
            // Handle error response
            saveButton.classList.remove('hidden');
            saving.classList.add('hidden');

            console.error('Error adding category:', xhr.responseText);
        }
    };

    // Send the request with the FormData object
    xhr.send(formData);

                });


                document.getElementById('cancelHeaderEdit').addEventListener("click", function () {
                    closeHeaderEditorModal(headerEditorModal);
                    document.getElementById('slides').style.display = 'flex';
                    document.getElementById('editorContent').style.display = 'block';
                });
            };

            document.getElementById('headerButton').onclick = function () {
                openHeaderEditorModal(prData);
                document.getElementById('editorStatus').value = 0;
            };


            function closeHeaderEditorModal(modal) {
                modal.remove();
                // Hide the overlay
                document.getElementById('overlay').classList.remove('show');
            };

    </script>

</span>

{{ slideShow | safe }}
    <!-- End of Slide Show and image uploader -->

<!-- </div>
<div class="con"> -->
<!-- Reach Text Editor -->
    {% set editorStatus = 0 %}
    {% set prStyle = "display: none" %}
    {% set editorStyle = "display: block" %}
    {% if prData.Text is none %}
        {% set prStyle = "display: block" %}
        {% set editorStyle = "display: none" %}
        {% set editorStatus = 1 %}
    {% endif %}
    
    

<!-- <div id="editorContentParent"> -->
<div id="editorContentParent">
    <span id="editorContent" class="ql-editor" style="{{ editorStyle }}"> 
        {% if prData.Text is not none %}
            <!-- {{ prData.Text | safe }} -->
        {% endif %}
    </span>
</div>

    <span class="blocks" id="myReachTextEditor" style="{{ prStyle }}">
<!-- 
    <div id="toolbar">
    </div>
     -->

    <div id="toolbar" class="customToolbar">
        <!-- Formatting buttons -->
        <button class="ql-bold"></button>
        <button class="ql-italic"></button>
        <button class="ql-underline"></button>
        <button class="ql-strike"></button>
      
        <!-- Blockquote, code-block -->
        <button class="ql-blockquote"></button>
        <button class="ql-code-block"></button>
      
        <!-- Link, image, video, formula -->
        <button class="ql-link"></button>
        <button class="ql-image"></button>
        <button class="ql-video"></button>
        <button class="ql-formula"></button>
      
        <!-- Headers -->
        <!-- <button class="ql-header" value="1"></button>
        <button class="ql-header" value="2"></button> -->
      
        <!-- Lists -->
        <button class="ql-list" value="ordered"></button>
        <button class="ql-list" value="bullet"></button>
        <button class="ql-list" value="check"></button>
      
        <!-- Script -->
        <button class="ql-script" value="sub"></button>
        <button class="ql-script" value="super"></button>
      
        <!-- Indent -->
        <button class="ql-indent" value="-1"></button>
        <button class="ql-indent" value="+1"></button>
      
        <!-- Direction -->
        <button class="ql-direction" value="rtl"></button>

        <!-- Size -->
        <select class="ql-size">
          <option value="small"></option>
          <!-- Note that the '' option means default size -->
          <option selected></option> 
          <option value="large"></option>
          <option value="huge"></option>


        </select>
      
        <!-- Header levels -->
        <select class="ql-header">
          <option value="1"></option>
          <option value="2"></option>
          <option value="3"></option>
          <option value="4"></option>
          <option value="5"></option>
          <option value="6"></option>
          <!-- Note that the 'false' option means paragraph -->
          <option selected></option> 
        </select>
      
        <!-- Font types -->
        <select class="ql-font">
          <!-- Options will be dynamically generated based on what's available in your theme/quill setup -->
        </select>
      
        <!-- Text alignment -->
        <select class="ql-align">
          <!-- Options will be dynamically generated based on what's available in your theme/quill setup -->
        </select>
      
        <!-- Clean formatting button -->
        <button class="ql-clean"></button>

        <!-- Text color, background color -->
        <span class="ql-formats">
            <button id="text-color-picker-btn" class="ql-color-picker"></button>
            <button id="background-color-picker-btn" class="ql-color-picker"></button>
        </span>
      </div>
      
      



        <!-- Quill.js editor container -->
        <div id="editor-container"></div>
        <!-- Button to submit content -->
        <div class="pcButton" id="submit-btn">{{ _('Submit') }}</div>
        <div id="saving-btn" class="hidden pcButton">{{ _('Saving...') }}</div>
    </span>
    <input type="hidden" id="editorStatus" value="{{ editorStatus }}"
    
<!-- End of Reach Text Editor -->

<script src="https://cdn.jsdelivr.net/npm/@simonwep/pickr/dist/pickr.min.js"></script>
    

<div id="submitted-content"></div>

<!-- Include Quill.js script -->
<!-- <script src="https://cdn.quilljs.com/1.3.6/quill.js"></script> -->
<script src="{{ url_for('static', filename='JS/1-3-6-quill.js') }}"></script>
<script>

document.addEventListener('DOMContentLoaded', function() {


   
    // Initialize Quill.js editor
    // const toolbarOptions = [
    //     ['bold', 'italic', 'underline', 'strike'],
    //     ['blockquote', 'code-block'],
    //     ['link', 'image', 'video', 'formula'],
    //     [{ 'header': 1 }, { 'header': 2 }],
    //     [{ 'list': 'ordered' }, { 'list': 'bullet' }, { 'list': 'check' }],
    //     [{ 'script': 'sub' }, { 'script': 'super' }],
    //     [{ 'indent': '-1' }, { 'indent': '+1' }],
    //     [{ 'direction': 'rtl' }],
    //     [{ 'size': ['small', false, 'large', 'huge'] }],
    //     [{ 'header': [1, 2, 3, 4, 5, 6, false] }],
    //     [{ 'color': [] }, { 'background': [] }],
    //     [{ 'font': [] }],
    //     [{ 'align': [] }],
    //     ['clean']
    // ];

    function imageHandler() {
            const input = document.createElement('input');
            input.setAttribute('type', 'file');
            input.setAttribute('accept', 'image/*');
            input.click();

            input.onchange = function () {
                const file = input.files[0];
                if (file) {
                    const reader = new FileReader();
                    reader.onload = function (e) {
                        const base64String = e.target.result;
                        const base64WithFileName = 'data:' + file.type + ';filename=' + file.name + ';base64,' + base64String.split(',')[1];
                        insertBase64Image(base64WithFileName);
                    };
                    reader.readAsDataURL(file);
                }
            };
        }

        function insertBase64Image(base64String) {
            const range = quill.getSelection();
            quill.insertEmbed(range.index, 'image', base64String);
        }

    // let Size = Quill.import('attributors/style/size');
    // Quill.register(Size, true);
    const quill = new Quill('#editor-container', {
        modules: { 
            // toolbar: toolbarOptions 
            toolbar: {
                    container: '#toolbar',
                    handlers: {
                        'image': imageHandler
                    }
                }
            
            // scrollingContainer: '#editor-container'
        },
        theme: 'snow'
    });



    // Initialize Quill editor
// const quill = new Quill('#editor', {
//     theme: 'snow',
//     modules: {
//         toolbar: toolbarOptions
//     }
// });

// Initialize Pickr for text color
const textColorPickr = Pickr.create({
    el: '#text-color-picker-btn',
    theme: 'classic',
    default: '#3E3E4547',
    components: {
        preview: true,
        opacity: true,
        hue: true,
        interaction: {
            hex: true,
            // rgba: true,
            // hsla: true,
            // hsva: true,
            // cmyk: true,
            input: true,
            clear: true,
            save: true
        }
    }
});

// Initialize Pickr for background color
const backgroundColorPickr = Pickr.create({
    el: '#background-color-picker-btn',
    theme: 'classic',
    default: '#935CA5A8',
    components: {
        preview: true,
        opacity: true,
        hue: true,
        interaction: {
            hex: true,
            // rgba: true,
            // hsla: true,
            // hsva: true,
            // cmyk: true,
            input: true,
            clear: true,
            save: true
        }
    }
});

// Update Quill editor when a text color is picked
textColorPickr.on('save', (color) => {
    const hexColor = color.toHEXA().toString();
    const range = quill.getSelection();
    if (range) {
        quill.format('color', hexColor);
    }
});

// Update Quill editor when a background color is picked
backgroundColorPickr.on('save', (color) => {
    const hexColor = color.toHEXA().toString();
    const range = quill.getSelection();
    if (range) {
        quill.format('background', hexColor);
    }
});


    document.getElementById('submit-btn').addEventListener('click', function (event) {
        let content = quill.root.innerHTML;
        let languageID = document.getElementById('language-id').value;
        let RefKey = document.getElementById('RefKey').value;
        event.preventDefault();

        const saveButton = document.getElementById('submit-btn');
        const saving = document.getElementById('saving-btn');

        saveButton.classList.add('hidden');
        saving.classList.remove('hidden');

        let formData = new FormData();
        formData.append('content', content);
        formData.append('language-id', languageID);
        formData.append('RefKey', RefKey);

        // Create a new XMLHttpRequest object
        var xhr = new XMLHttpRequest();

        // Configure the request
        xhr.open('POST', '/submit_product_text');
        xhr.setRequestHeader('X-CSRFToken', csrfToken);

        // Define what happens on successful data submission
        xhr.onload = function () {
            if (xhr.status === 200) {
                var response = JSON.parse(xhr.responseText);

                var mistakesDiv = document.getElementById('mistakes');
                mistakesDiv.innerHTML = ''; // Clear previous messages

            if (response.status === '1') {
                    // Handle success
                    let RefKey = document.getElementById('RefKey').value;
                    let prURL = window.location.origin  + '/product/' + RefKey;
                    location.href = prURL;
                }
            } else {
                // Handle error response
                saveButton.classList.remove('hidden');
                saving.classList.add('hidden');

                console.error('Error adding category:', xhr.responseText);
            }
        };

        // Send the request with the FormData object
        xhr.send(formData);
        });


    // Function to convert HTML to Delta
    function convertHtmlToDelta(html) {
        const container = document.createElement('div');
        container.innerHTML = html;
        return quill.clipboard.convert(container);
    }

    document.querySelectorAll('.chooseBlock').forEach(item => {
        item.addEventListener('click', function (event) {
            const clickedId = event.currentTarget.id;
            document.getElementById("topLeftNav").classList.toggle('collapsed');

            // Hide all elements with the class 'blocks'
            // if (clickedId === "textEditorButton") {
                document.querySelectorAll('.blocks').forEach(block => {
                    if (!block.id === 'mySlideShow') {
                    }                        
                        block.style.display = 'none'; 
                });

            // } else {
            //     document.querySelectorAll('.blocks').forEach(block => {
            //         block.style.display = 'none'; 
            //     });
            // }

            
            // Get the id of the clicked element
            
            // Conditionally show the correct element based on the clicked id
            if (clickedId === 'sliderButton') {
                document.getElementById("editorContent").style.display = "none";
                document.getElementById("editorStatus").value = 0; // This is for reach text editor hide-show manipulations
                document.getElementById(clickedId).innerHTML = "{{ _('Loading...') }}";
                
                let languageID = prData.LanguageID;
                let ProductID = prData.Product_ID;

                let formData = new FormData();
                formData.append('languageID', languageID);
                formData.append('ProductID', ProductID);

                // Create a new XMLHttpRequest object
                let xhr = new XMLHttpRequest();

                // Configure the request
                xhr.open('POST', '/get_slides');
                xhr.setRequestHeader('X-CSRFToken', csrfToken);

                // Define what happens on successful data submission
                xhr.onload = function () {
                    if (xhr.status === 200) {
                        let response = JSON.parse(xhr.responseText);
                        
                        // Add image from url to dropzone

                        // Helper function to fetch images and maintain order
                        function fetchImage(imgName, AltText, src, sliderID) {
                            return new Promise((resolve, reject) => {
                                if (imgName.length > 0) {
                                    let url = window.location.origin + '/static/images/' + src + '/' + imgName;
                                    let fileType = "image/" + imgName.split('.').pop();

                                    fetch(url)
                                        .then(response => response.blob())
                                        .then(blob => {
                                            let file = new File([blob], imgName, { type: fileType });
                                            resolve({ file: file, altText: AltText, sliderId: sliderID });
                                        })
                                        .catch(error => {
                                            console.error('Error fetching the image:', error);
                                            reject(error);
                                        });
                                }
                            });
                        }

                        // Array to keep the images and alt texts in the desired order
                        const imagesToAdd = response;

                        let src = 'product_slider';
                        
                        // Clear all images from Dropzone before fetching and adding new images
                        myDropzone.removeAllFiles(true); // 'true' will ensure even files marked as 'uploaded' are removed
                        
                        // Fetch all images and add them to Dropzone in the correct order
                        Promise.all(imagesToAdd.map(img => fetchImage(img.imgName, img.AltText, src, img.sliderID)))
                            .then(fetchedImages => {
                                fetchedImages.forEach(({ file, altText, sliderId }) => {
                                    imgAlt = altText;
                                    slider_id = sliderId;
                                    myDropzone.addFile(file);
                                    imgAlt = '';
                                    slider_id = '';
                                });
                            })
                            .catch(error => console.error('Error adding images:', error));
                        
                        // End of Add image from url to dropzone


                        
                    } else {
                        // Handle error response
                        console.error('Error adding category:', xhr.responseText);
                    }
                };

                // Send the request with the FormData object
                xhr.send(formData);
            

                document.getElementById(clickedId).innerHTML = "{{ _('Slider') }}";
                document.getElementById('mySlideShow').style.display = 'block';
                document.getElementById('mySlideShow').classList.remove('hidden');

            } else if (clickedId === 'thumbnailButton') {
                urlTo = window.location.origin + '/pr-thumbnail/' + {{ prData.RefKey }}
                window.location = urlTo
                // alert(urlTo)
            } else if (clickedId === 'textEditorButton') {
                let ReachTextEditorSpan = document.getElementById("myReachTextEditor");
                let editorContent = document.getElementById("editorContent");
                let editorStatus = document.getElementById("editorStatus").value;
                if (editorStatus == 1) {
                    // ReachTextEditorSpan = document.getElementById("myReachTextEditor");
                    ReachTextEditorSpan.style.display = 'none';
                    editorContent.style.display = 'block';
                    document.getElementById("editorStatus").value = 0;
                    
                    // Get the length of the inserted content
                    let insertedContentLength = quill.getLength();
                    if (insertedContentLength > 0) {
                        // Remove the inserted content
                        quill.deleteText(0, insertedContentLength);
                    }     


                } else {
                    let htmlToInsert = prData.Text
                    
                    // alert(htmlToInsert)
                    if (htmlToInsert !== null) {
                        
                        quill.clipboard.dangerouslyPasteHTML(0, htmlToInsert);
                        // quill.setText(delta);
                    
                    }
                    
                    editorContent.style.display = 'none';
                    ReachTextEditorSpan.style.display = 'block';
                    document.getElementById("editorStatus").value = 1;
                }

            }
        });
    });
});

    document.getElementById('mySwitch').addEventListener('click', function() {
        const slider = this.querySelector('.sliderA');
        let product_status = '';
        slider.classList.toggle('checked');  
        if (slider.classList.contains('checked')) {
            // Action to be performed when switch is on
            product_status = '2'
        } else {
            // Action to be performed when switch is off
            product_status = '1'
        }

        let languageID = document.getElementById('language-id').value;
        let RefKey = document.getElementById('RefKey').value;

        let formData = new FormData();
        formData.append('languageID', languageID);
        formData.append('RefKey', RefKey);
        formData.append('productStatus', product_status);

        // Create a new XMLHttpRequest object
        var xhr = new XMLHttpRequest();

        // Configure the request
        xhr.open('POST', '/publish-product');
        xhr.setRequestHeader('X-CSRFToken', csrfToken);

        // Define what happens on successful data submission
        xhr.onload = function () {
            if (xhr.status === 200) {
                var response = JSON.parse(xhr.responseText);

                if (response.status === '1') {
                    // Handle success
                    alert(response.answer);
                    window.location.reload(); 
                }
            } else {
                // Handle error response
                console.error('Error adding category:', xhr.responseText);
            }
        };

        // Send the request with the FormData object
        xhr.send(formData);
    });




    // let htmlToInsert = prData.Text
    let savedHtmlContent = prData.Text 
    document.getElementById('editorContent').innerHTML = savedHtmlContent;


document.addEventListener('DOMContentLoaded', () => {
    document.getElementById('myDropzone').addEventListener('click', function() {
        cropperState = 1;    
    });


    
            // Handle the file upload when the button is clicked
            let uploadButton = document.getElementById("uploadButton");
            let saving = document.getElementById("saveUploads");
            
            uploadButton.addEventListener("click", function () {
                uploadButton.style.display = 'none';
                saving.style.display = 'inline-block';

                // Create a FormData object to hold the files
                let formData = new FormData();

                console.log(myDropzone.files)

        let i = 0
        myDropzone.files.forEach(function (file) {
            let fileName = "file_" + i;
            formData.append(fileName, file);

            // Add the alt text as a separate field if available
            let altInput = file.previewElement.querySelector(".alt-input");
            let altText = altInput ? altInput.value : ''; // Use empty string if altInput is missing
            let altTextName = "alt_text_" + i;
            formData.append(altTextName, altText);

            // Add the id of slider as a separate field if available
            let slideIDInput = file.previewElement.querySelector(".slideID");
            let slideID = slideIDInput ? slideIDInput.value : ''; // Use empty string if altInput is missing
            let slideIDName = "slideID_" + i;
            formData.append(slideIDName, slideID);

            // Add upload status as a separate field if available
            // If upload status is 0 server will upload new image
            // if upload status is 1 server will get image from repositiry
            // Then will check and change the order of image if needed
            let uploadStatusInput = file.previewElement.querySelector(".uploadStatus");
            let uploadStatusValue = uploadStatusInput ? uploadStatusInput.value : '0'; // Default to '0' if missing
            let uploadStatus = "upload_status_" + i;
            formData.append(uploadStatus, uploadStatusValue);

            i++;
      
    });

                let fileStatus = true;  
                if (i === 0) {
                    fileStatus = false;
                } 
                formData.append('fileStatus', fileStatus); 
                
                let languageID = prData.LanguageID;
                let ProductID = prData.Product_ID;

                // formData.append("languageID", languageID);
                formData.append("ProductID", ProductID);
                formData.append("Type", '1');

                // Create a new XMLHttpRequest object
                let xhr = new XMLHttpRequest();
                
                // Configure the request
                xhr.open('POST', '/upload_slides');                   
                xhr.setRequestHeader('X-CSRFToken', csrfToken);

                // Define what happens on successful data submission
                xhr.onload = function () {
                    if (xhr.status === 200) {
                        var response = JSON.parse(xhr.responseText);

                        var mistakesDiv = document.getElementById('mistakes');
                        mistakesDiv.innerHTML = ''; // Clear previous messages
                        
                        if (response.status === '0') {
                            // Handle Unknown Error
                            mistakesDiv.textContent = response.answer;
                            // mistakesDiv.style.color = 'red';
                            mistakesDiv.style.display = 'flex';

                            saving.style.display = 'none';
                            uploadButton.style.display = 'inline-block';
                            
                            // Scroll the window to the mistakesDiv with smooth behavior
                            mistakesDiv.scrollIntoView({ behavior: 'smooth' });                              
                            
                            
                        } else if (response.status === '1') {
                            mistakesDiv.style.display = 'none';
                            saving.style.display = 'none';
                            uploadButton.style.display = 'inline-block';

                            console.log(response.answer)
                            // Handle success
                            alert(response.answer);
                            let currentUrl = window.location.href;
                            location.href = currentUrl;
                        }
                    } else {
                        // Handle error response
                        uploadButton.classList.remove('hidden');
                        saving.classList.add('hidden');

                        console.error('Error adding category:', xhr.responseText);
                    }
                };

                // Send the request with the FormData object
                xhr.send(formData);


            });

    // Adjusts uploadStatus to 0 if any change was made to nearest input element with alt-input class
    document.addEventListener('input', function (event) {
    // Check if the changed element has the 'alt-input' class
    if (event.target.classList.contains('alt-input')) {
        // Find the nearest uploadStatus input
        const uploadStatusInput = event.target.closest('div')?.querySelector('.uploadStatus');
        
        if (uploadStatusInput) {
            // Set its value to 0
            uploadStatusInput.value = 0;
        }
    }
    });
});   


document.querySelector('.changePrOrder').onchange = function(event) {
    const order = this.value;
    const prID = prData.Product_ID;

    let formData = new FormData();
        formData.append('order', order);
        formData.append('prID', prID);

        // Create a new XMLHttpRequest object
        var xhr = new XMLHttpRequest();

        // Configure the request
        xhr.open('POST', '/changeprorder');
        xhr.setRequestHeader('X-CSRFToken', csrfToken);

        // Define what happens on successful data submission
        xhr.onload = function () {
            if (xhr.status === 200) {
                let response = JSON.parse(xhr.responseText);

                if (response.status === '1') {
                    // Handle success
                    let RefKey = document.getElementById('RefKey').value;
                    let prURL = window.location.origin  + '/product/' + RefKey;
                    location.href = prURL;
                } else {
                    alert(response.answer)
                }
            } else {
                console.error('Error adding category:', xhr.responseText);
            }
        };

        // Send the request with the FormData object
        xhr.send(formData);
};
</script>

{% endblock %}