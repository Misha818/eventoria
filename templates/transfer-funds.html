{% extends "base.html" %}

{% block title %}
    {{ _('Transfer funds') }}
{% endblock %}

{% block head %}

<link rel="stylesheet" href="{{ url_for('static', filename='quill.snow.css') }}">
<link href="https://fonts.googleapis.com/css?family=Roboto|Montserrat|Lato|Oswald|Playfair+Display|Raleway" rel="stylesheet">
<style>
.ql-snow .ql-picker.ql-font .ql-picker-label::before, .ql-snow .ql-picker.ql-font .ql-picker-item::before {
    content: 'Roboto';
}

.ql-snow .ql-picker.ql-font {
    width: 120px;
}
</style>

{% endblock %}

{% block content %}

{{ sideBar | safe }}



<div class="container toRight" id="tableDaddy" style="width: 70%;">
<div id="response"></div>
<div class="mb-3 transfer-funds">

    {% if result.length > 0 %}
        <select id="recipient" class="styled-select" style="margin-bottom: unset;">
            <option value="">{{ _('Choose recipient') }}</option>
            {% for val in result.data %}
                {% set optVal = val['Initials'] + ' ' + val['Rol'] %}
                {% if optVal is not none %}
                {% endif %}
                {% set selected = '' %}
                {% if stuffID == val['ID'] %}
                    {% set selected = 'selected' %}
                {% endif %}
                <option value="{{ val['ID'] }}" {{ selected }}>
                    {{ optVal }}
                </option>
            {% endfor %}
        </select>
        
    {% endif %}
    <input type="text" id="name" name="name" placeholder="{{ _('Amount') }}"  style="width: 100%; height: 45px;">

    <!-- Quill.js editor container -->
    <div id="editor" ></div>
</div>


</div>

<div class="containerH">

    <div class="pcButtonS" id="submit">{{ _('Submit')}}</div>
    <div class="pcButtonS hidden" id="saving">{{ _('Saving...')}}</div>
</div>

<script src="{{ url_for('static', filename='JS/1-3-6-quill.js') }}"></script>
<script>

document.addEventListener('DOMContentLoaded', function() {
    
    function imageHandler() {
            const input = document.createElement('input');
            input.setAttribute('type', 'file');
            input.setAttribute('accept', 'image/*');
            input.click();

            input.onchange = function () {
                const file = input.files[0];
                if (file) {
                    const reader = new FileReader();
                    reader.onload = function (e) {
                        const base64String = e.target.result;
                        const base64WithFileName = 'data:' + file.type + ';filename=' + file.name + ';base64,' + base64String.split(',')[1];
                        insertBase64Image(base64WithFileName);
                    };
                    reader.readAsDataURL(file);
                }
            };
        }

        function insertBase64Image(base64String) {
            const range = quill.getSelection();
            quill.insertEmbed(range.index, 'image', base64String);
        }









        

        // 1. Import the Font format from Quill
const Font = Quill.import('formats/font');

// 2. Create an array of font keys
//    Use simple, lowercase strings (no spaces) to avoid Quill confusion
//    For multi-word fonts like "Playfair Display", pick a single string, e.g. 'playfair-display'
const fonts = [
  'roboto',
  'montserrat',
  'lato',
  'oswald',
  'playfair-display',
  'raleway'
];

// 3. Whitelist the fonts and register them
Font.whitelist = fonts;
Quill.register(Font, true);

       
    // Initialize Quill.js editor
    const toolbarOptions = [
        ['bold', 'italic', 'underline', 'strike'],
        ['blockquote', 'code-block'],
        // ['link', 'image', 'video', 'formula'],
        ['link', 'image'],
        // [{ 'header': 1 }, { 'header': 2 }],
        [{ 'list': 'ordered' }, { 'list': 'bullet' }, { 'list': 'check' }],
        // [{ 'script': 'sub' }, { 'script': 'super' }],
        [{ 'indent': '-1' }, { 'indent': '+1' }],
        [{ 'direction': 'rtl' }],
        [{ 'size': ['small', false, 'large', 'huge'] }],
        [{ 'header': [1, 2, 3, 4, 5, 6, false] }],
        [{ 'color': [] }, { 'background': [] }],
        // [{ 'font': ['roboto', 'montserrat', 'lato', 'oswald', 'playfair', 'raleway'] }],
        [{ 'font': fonts }]
    ];



const quill = new Quill('#editor', {
  theme: 'snow',
  placeholder: "{{ _('Additional notes') }}",
  modules: {
    toolbar: {
      container: toolbarOptions, 
      handlers: {
        image: imageHandler
      }
    }
  }
});



// Select the target element
const fontLabel = document.querySelector('.ql-font .ql-picker-label');

if (fontLabel) {
  // Create a MutationObserver instance to watch for attribute changes
  const observer = new MutationObserver((mutationsList) => {
    mutationsList.forEach((mutation) => {
      if (mutation.type === 'attributes' && mutation.attributeName === 'data-value') {
        const newValue = fontLabel.getAttribute('data-value');
        console.log('New data-value:', newValue);
        updateCSSContent(newValue);
      }
    });
  });

  // Start observing the target element for attribute changes to 'data-value'
  observer.observe(fontLabel, { attributes: true, attributeFilter: ['data-value'] });
} else {
  console.warn('Element .ql-font .ql-picker-label not found');
}


// Function to update (or create) a style element with new CSS rule
function updateCSSContent(newValue) {
  newValue = formatFontName(newValue); 
  // Try to find an existing style element we can update
  let styleElem = document.getElementById('dynamic-font-style');
  if (!styleElem) {
    styleElem = document.createElement('style');
    styleElem.id = 'dynamic-font-style';
    document.head.appendChild(styleElem);
  }
  // Update the CSS rule. The content property must be quoted.
  styleElem.innerHTML = `
    .ql-snow .ql-picker.ql-font .ql-picker-label::before,
    .ql-snow .ql-picker.ql-font .ql-picker-item::before {
      content: '${newValue}';
      font-family: '${newValue}';
    }
  `;
}


function formatFontName(fontKey) {
  return fontKey
    .split('-') // split by dash
    .map(word => word.charAt(0).toUpperCase() + word.slice(1)) // capitalize each part
    .join(' '); // rejoin with space
}




});

        let csrfToken = "{{ csrf_token() }}";
            document.getElementById('submit').onclick = function() {
                event.preventDefault(); // Prevent form submission
                let response = document.querySelector("#response");
                response.innerHTML = "";
                response.style.display = 'none';

                let answer;
                let flag = false;
                const docFormData = new FormData(document.getElementById("myForm"));

                let project_name = document.getElementById("name").value;
                if (!project_name) {
                    response.innerHTML = "{{ _('Please specify subproduct situation name!') }}";
                    response.style.display = 'flex';
                    document.getElementById("name").style.borderColor = "red";
                    return;
                }

                document.getElementById("name").style.borderColor = "black";

                let formData = new FormData();
            
                let i = 0;
                docFormData.forEach((value, key) => {
                    const inputElement = document.querySelector(`[name="${key}"]`);
                    const elementType = inputElement.type;

                    let stringToSplit = key;
                    let checker = stringToSplit.indexOf("_");
                    let parentElementId = "";
                    if (checker !== -1) {
                        let splitArray = stringToSplit.split('_');
                        let secondIndex = splitArray[1];
                        parentElementId = "parent_" + secondIndex;
                    }

                    let emptyInput = document.querySelector(`#${parentElementId} input`);

                    if (value === "") {
                        flag = true;

                        if (elementType === "select-one") {
                            if (colorFrame) {
                                colorFrame.style.color = "red";
                            }
                        } else {
                            if (emptyInput) {
                                emptyInput.style.borderColor = "red";
                            }
                        }
                    } else {
                        if (elementType === "select-one") {
                            if (colorFrame) {
                                colorFrame.style.color = "black";
                            }
                        } else {
                            if (emptyInput) {
                                emptyInput.style.borderColor = "black";
                            }
                        }
                    }

                    let check = key.split('_');
                    if (check[0] !== "type") {
                        formData.append('text_' + i.toString(), value)
                        i++;
                    }
                });

                if (flag) {
                    answer = "{{ _('Please improve all red fields!') }}";
                    response.textContent = answer;
                    response.style.display = 'flex';
                    return;
                }

        formData.append('spsName', project_name)     
        document.querySelector("#response").textContent = answer;

        // Create a new XMLHttpRequest object
        let xhr = new XMLHttpRequest();
        
        // Configure the request
        xhr.open('POST', '/add_sps');
        xhr.setRequestHeader('X-CSRFToken', csrfToken);

        // Define what happens on successful data submission
        xhr.onload = function () {
            if (xhr.status === 200) {
                const response = JSON.parse(xhr.responseText);
                if (response.status === '1') {
                    let ptsURL = window.location.origin  + '/pt-specifications';
                    location.href = ptsURL;
                }
                
                if (response.status === '0') {
                    document.querySelector("#response").textContent = response.answer;
                    document.querySelector("#response").style.display = 'flex';
                } 
                
                if (response.status === 'test') {
                    const jsonString = JSON.stringify(response.message);
                    document.querySelector('#response').textContent = jsonString;
                }
            } else {
                console.error('Request failed with status: ' + xhr.status);
            }
        };

        // Define what happens in case of error
        xhr.onerror = function () {
            console.error('Request failed.');
        };

        // Send the request with the JSON data
        xhr.send(formData);
    };

  
    </script>

{% endblock %}
